# .github/workflows/deploy-to-staging.yml
name: Joomart Monorepo Staging CI/CD Pipeline

# This workflow will run on push to main, or on pull requests to either main or staging.
# This ensures that all CI steps (building, testing) run for every proposed change.
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
      - staging
    types:
      - opened
      - synchronize
      - reopened
  workflow_dispatch:

# Define global environment variables for the workflow
env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}

jobs:
  # The 'determine-changes' job identifies which services have been modified
  # in the current commit or pull request. This is a critical step for
  # optimizing monorepo CI/CD pipelines.
  determine-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.check.outputs.services }}
      # New output specifically for the services that need to be built
      buildable_services: ${{ steps.check.outputs.buildable_services }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to compare branches

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44

      - name: Determine affected services
        id: check
        run: |
          AFFECTED_SERVICES=()

          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            case "$file" in
              frontend/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " frontend " ]]; then
                  AFFECTED_SERVICES+=("frontend")
                fi
                ;;
              backend/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " backend " ]]; then
                  AFFECTED_SERVICES+=("backend")
                fi
                ;;
              api/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " api " ]]; then
                  AFFECTED_SERVICES+=("api")
                fi
                ;;
              .github/workflows/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " workflows " ]]; then
                  AFFECTED_SERVICES+=("workflows")
                fi
                ;;
            esac
          done

          # Manually build the JSON strings to ensure there is no extra whitespace.
          # This is the most reliable method for this type of task.
          services_string=""
          buildable_string=""

          if [ ${#AFFECTED_SERVICES[@]} -gt 0 ]; then
            for service in "${AFFECTED_SERVICES[@]}"; do
              if [ -n "$services_string" ]; then
                services_string+=","
              fi
              services_string+="\"$service\""

              if [[ "$service" != "workflows" ]]; then
                if [ -n "$buildable_string" ]; then
                  buildable_string+=","
                fi
                buildable_string+="\"$service\""
              fi
            done
            
            echo "services=[$services_string]" >> $GITHUB_OUTPUT
            echo "buildable_services=[$buildable_string]" >> $GITHUB_OUTPUT
          else
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "buildable_services=[]" >> $GITHUB_OUTPUT
          fi

          # This step is for debugging and will show the exact output in your job logs
          echo "Debug: services output is [$services_string]"
          echo "Debug: buildable_services output is [$buildable_string]"

  # The 'build-and-push' job builds a Docker image for each affected service
  # and pushes it to the GitHub Container Registry (GHCR).
  build-and-push:
    needs: determine-changes
    # This conditional is crucial: only run this job if the buildable services array is not empty
    # Use a direct string comparison to avoid potential parsing issues
    if: needs.determine-changes.outputs.buildable_services != '[]'
    # Use the JSON output from the previous job to dynamically define the matrix
    strategy:
      matrix:
        # We now use the filtered list of services that are actually buildable.
        service: ${{ fromJson(needs.determine-changes.outputs.buildable_services) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ${{ matrix.service }} image
        uses: docker/build-push-action@v6
        with:
          context: ./${{ matrix.service }}
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.OWNER }}/${{ matrix.service }}:latest
      - name: Notify build success
        run: |
          echo "Build and push for ${{ matrix.service }} successful!"

  # The 'deploy-to-staging' job is responsible for deploying the latest images
  # to your staging environment. It will now run on a push to 'main' or a PR to 'staging'.
  deploy-to-staging:
    needs: build-and-push
    # This conditional has been updated to be more flexible.
    # It now triggers on a push to main or a pull request to staging.
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'pull_request' && github.base_ref == 'staging')
    runs-on: self-hosted # This requires a self-hosted runner on your VPS
    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy services to staging
        run: |
          docker compose -f docker-compose/staging/docker-compose.yml pull
          docker compose -f docker-compose/staging/docker-compose.yml up -d --remove-orphans
      - name: Notify deployment success
        run: |
          echo "Deployment to staging successful!"
