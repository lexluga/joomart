name: Joomart Monorepo Staging CI/CD Pipeline

# This workflow will run on push to main, or on pull requests to either main or staging.
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
      - staging
    types:
      - opened
      - synchronize
      - reopened
  workflow_dispatch:

# Define global environment variables for the workflow

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}

jobs:
  # The 'determine-changes' job identifies which services have been modified
  # in the current commit or pull request.
  determine-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.check.outputs.services }}
      # New output specifically for the services that need to be built
      buildable_services: ${{ steps.check.outputs.buildable_services }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to compare branches

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44

      - name: Determine affected services
        id: check
        run: |
          AFFECTED_SERVICES=()

          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            case "$file" in
              frontend/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " frontend " ]]; then
                  AFFECTED_SERVICES+=("frontend")
                fi
                ;;
              backend/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " backend " ]]; then
                  AFFECTED_SERVICES+=("backend")
                fi
                ;;
              api/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " api " ]]; then
                  AFFECTED_SERVICES+=("api")
                fi
                ;;
              .github/workflows/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " workflows " ]]; then
                  AFFECTED_SERVICES+=("workflows")
                fi
                ;;
            esac
          done

          # Manually build the JSON strings to ensure there is no extra whitespace.
          services_string=""
          buildable_string=""

          if [ ${#AFFECTED_SERVICES[@]} -gt 0 ]; then
            for service in "${AFFECTED_SERVICES[@]}"; do
              if [ -n "$services_string" ]; then
                services_string+=","
              fi
              services_string+="\"$service\""

              if [[ "$service" != "workflows" ]]; then
                if [ -n "$buildable_string" ]; then
                  buildable_string+=","
                fi
                buildable_string+="\"$service\""
              fi
            done

            echo "services=[$services_string]" >> $GITHUB_OUTPUT
            echo "buildable_services=[$buildable_string]" >> $GITHUB_OUTPUT
          else
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "buildable_services=[]" >> $GITHUB_OUTPUT
          fi

          # This step is for debugging and will show the exact output in your job logs
          echo "Debug: services output is [$services_string]"
          echo "Debug: buildable_services output is [$buildable_string]"

  # The 'build-and-push' job now performs Build, Security Scan, and Push for each affected service.
  build-and-push:
    needs: determine-changes
    # This conditional is crucial: only run this job if the buildable services array is not empty
    if: needs.determine-changes.outputs.buildable_services != '[]'
    strategy:
      matrix:
        # We now use the filtered list of services that are actually buildable.
        service: ${{ fromJson(needs.determine-changes.outputs.buildable_services) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 1. Build and LOAD the image locally for scanning (DO NOT PUSH YET)
      - name: Build and Load ${{ matrix.service }} image for scanning
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./dockerfiles/Dockerfile.${{ matrix.service }}.prod
          # Use a temporary local tag for scanning
          tags: ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:scan-temp
          load: true # <-- Loads the image into the Docker daemon for Trivy to use
          target: production
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:buildcache,mode=max

      # 2. Run Trivy Vulnerability Scan (THE QUALITY GATE)
      - name: Run Trivy vulnerability scanner on ${{ matrix.service }}
        id: trivy
        uses: aquasecurity/trivy-action@0.33.1
        # CRITICAL FIX: Allows subsequent steps to run even if this step fails (exit-code: 1)
        # The job will still show as failed, but the SARIF file will be written.
        continue-on-error: true
        with:
          # Scan the temporary local image
          image-ref: ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:scan-temp
          format: "sarif"
          output: "trivy-results-${{ matrix.service }}.sarif"
          exit-code: 1 # CRITICAL: This ensures the step fails if vulnerabilities are found
          ignore-unfixed: true # Only look for vulnerabilities with known fixes
          severity: "CRITICAL,HIGH" # Only fail on these severity levels

        # --- FILE PERSISTENCE FIX ---
      # This step explicitly checks if the SARIF file was created and sets an output variable.
      # This addresses the race condition where the Trivy step fails before writing the file.
      - name: Verify SARIF File Existence
        id: check_file
        run: |
          SARIF_FILE="trivy-results-${{ matrix.service }}.sarif"
          if [ -f "$SARIF_FILE" ]; then
            echo "::notice::SARIF file found: $SARIF_FILE"
            echo "file_exists=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::SARIF file NOT found: $SARIF_FILE. Upload will be skipped, but deployment gate remains active."
            echo "file_exists=false" >> $GITHUB_OUTPUT
          fi

      # 3. Upload Trivy results to GitHub Security tab
      # We now conditionally run this only if the file was verified to exist.
      - name: Upload Trivy scan results to GitHub Security tab
        if: always() && steps.check_file.outputs.file_exists == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results-${{ matrix.service }}.sarif"

  # The 'deploy-to-staging' job is responsible for deploying the latest images
  # to your staging environment.
  deploy-to-staging:
    needs: build-and-push
    # This conditional has been updated to be more flexible.
    if: |
      needs.build-and-push.result == 'success' &&
      (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        (github.event_name == 'pull_request' && github.base_ref == 'staging')
      )
    runs-on: self-hosted # This requires a self-hosted runner on your VPS
    steps:
      - name: Checkout code
        # You need to checkout the code again here so it's available in the self-hosted runner
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create .env.db file
        run: |
          mkdir -p config/mysql/
          echo "${{ secrets.MYSQL_ENV_FILE }}" > /tmp/.env.db
          mv /tmp/.env.db config/mysql/.env.db

      - name: Deploy services to staging
        # Tell the step to run from the root of the repository
        working-directory: ${{ github.workspace }}
        run: |
          docker compose -f docker-compose/staging/docker-compose.yml pull --ignore-pull-failures
          docker compose -f docker-compose/staging/docker-compose.yml up -d --remove-orphans

      - name: Notify deployment success
        run: |
          echo "Deployment to staging successful!"
