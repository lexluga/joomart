name: Joomart Monorepo Staging CI/CD Pipeline

# This workflow will run on push to main, or on pull requests to either main or staging.
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
      - staging
    types:
      - opened
      - synchronize
      - reopened
  workflow_dispatch:

# Define global environment variables for the workflow

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}

jobs:
  # The 'determine-changes' job identifies which services have been modified
  # in the current commit or pull request.
  determine-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.check.outputs.services }}
      # New output specifically for the services that need to be built
      buildable_services: ${{ steps.check.outputs.buildable_services }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to compare branches

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44

      - name: Determine affected services
        id: check
        run: |
          AFFECTED_SERVICES=()

          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            case "$file" in
              frontend/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " frontend " ]]; then
                  AFFECTED_SERVICES+=("frontend")
                fi
                ;;
              backend/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " backend " ]]; then
                  AFFECTED_SERVICES+=("backend")
                fi
                ;;
              api/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " api " ]]; then
                  AFFECTED_SERVICES+=("api")
                fi
                ;;
              .github/workflows/*)
                if [[ ! " ${AFFECTED_SERVICES[@]} " =~ " workflows " ]]; then
                  AFFECTED_SERVICES+=("workflows")
                fi
                ;;
            esac
          done

          # Manually build the JSON strings to ensure there is no extra whitespace.
          services_string=""
          buildable_string=""

          if [ ${#AFFECTED_SERVICES[@]} -gt 0 ]; then
            for service in "${AFFECTED_SERVICES[@]}"; do
              if [ -n "$services_string" ]; then
                services_string+=","
              fi
              services_string+="\"$service\""

              if [[ "$service" != "workflows" ]]; then
                if [ -n "$buildable_string" ]; then
                  buildable_string+=","
                fi
                buildable_string+="\"$service\""
              fi
            done

            echo "services=[$services_string]" >> $GITHUB_OUTPUT
            echo "buildable_services=[$buildable_string]" >> $GITHUB_OUTPUT
          else
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "buildable_services=[]" >> $GITHUB_OUTPUT
          fi

          # This step is for debugging and will show the exact output in your job logs
          echo "Debug: services output is [$services_string]"
          echo "Debug: buildable_services output is [$buildable_string]"

  # The 'build-and-push' job now performs Build, Security Scan, and Push for each affected service.
  build-and-push:
    needs: determine-changes
    # This conditional is crucial: only run this job if the buildable services array is not empty
    if: needs.determine-changes.outputs.buildable_services != '[]'
    strategy:
      matrix:
        # We now use the filtered list of services that are actually buildable.
        service: ${{ fromJson(needs.determine-changes.outputs.buildable_services) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 1. Build and LOAD the image locally for scanning (DO NOT PUSH YET)
      - name: Build and Load ${{ matrix.service }} image for scanning
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./dockerfiles/Dockerfile.${{ matrix.service }}.prod
          # Use a temporary local tag for scanning
          tags: ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:scan-temp
          load: true # <-- Loads the image into the Docker daemon for Trivy to use
          target: production
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:buildcache,mode=max

      # 2. Run Trivy Vulnerability Scan (THE QUALITY GATE)
      - name: Run Trivy vulnerability scanner on ${{ matrix.service }}
        id: trivy
        uses: aquasecurity/trivy-action@0.33.1
        # CRITICAL FIX: Allows subsequent steps to run even if this step fails (exit-code: 1)
        # The job will still show as failed, but the SARIF file will be written.
        continue-on-error: true
        with:
          # Scan the temporary local image
          image-ref: ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:scan-temp
          format: "sarif"
          output: "trivy-results-${{ matrix.service }}.sarif"
          exit-code: 1 # CRITICAL: This ensures the step fails if vulnerabilities are found
          ignore-unfixed: true # Only look for vulnerabilities with known fixes
          severity: "CRITICAL,HIGH" # Only fail on these severity levels

      # 3. Push the image to the Registry (Only runs if the scan passed)
      - name: Push ${{ matrix.service }} image to Registry
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./dockerfiles/Dockerfile.${{ matrix.service }}.prod
          push: true # <-- Now we push, as the scan passed
          # Reuse tags defined in the original workflow
          tags: |
            ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:staging
            ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:latest
            ${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:${{ github.sha }}
          target: production # Ensure the correct target is used for the push
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.OWNER }}/joomart-${{ matrix.service }}:buildcache,mode=max

      # 4. Upload Trivy results to GitHub Security tab (always run so results appear even if scan found issues)
      - name: Upload Trivy scan results to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results-${{ matrix.service }}.sarif"

      - name: Notify build success
        run: |
          echo "Build, Scan, and Push for ${{ matrix.service }} successful!"

  # The 'deploy-to-staging' job is responsible for deploying the latest images
  # to your staging environment.
  deploy-to-staging:
    needs: build-and-push
    # This conditional has been updated to be more flexible.
    if: |
      needs.build-and-push.result == 'success' &&
      (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        (github.event_name == 'pull_request' && github.base_ref == 'staging')
      )
    runs-on: self-hosted # This requires a self-hosted runner on your VPS
    steps:
      - name: Checkout code
        # You need to checkout the code again here so it's available in the self-hosted runner
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create .env.db file
        run: |
          mkdir -p config/mysql/
          echo "${{ secrets.MYSQL_ENV_FILE }}" > /tmp/.env.db
          mv /tmp/.env.db config/mysql/.env.db

      - name: Deploy services to staging
        # Tell the step to run from the root of the repository
        working-directory: ${{ github.workspace }}
        run: |
          docker compose -f docker-compose/staging/docker-compose.yml pull --ignore-pull-failures
          docker compose -f docker-compose/staging/docker-compose.yml up -d --remove-orphans

      - name: Notify deployment success
        run: |
          echo "Deployment to staging successful!"
